(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{62:function(e,t,s){"use strict";s.r(t);var r=s(0),_=Object(r.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("div",{staticClass:"content"},[e._m(0),e._v(" "),s("p",[e._v("关于Vue的开发规范参考了官方的"),s("a",{attrs:{href:"https://cn.vuejs.org/v2/style-guide/",target:"_blank",rel:"noopener noreferrer"}},[e._v("风格指南"),s("OutboundLink")],1),e._v("，更多规范再次没有列出来，但强烈建议大家详细阅读官方\n的开发指南，在实际开发中尽可能的遵循官方风格指南。")]),e._v(" "),e._m(1),e._v(" "),e._m(2),e._v(" "),e._m(3),e._v(" "),s("ul",[s("li",[e._v("v-bind、v-on等有简写形式的，一律采用简写形式，尽量保持代码简洁统一；")]),e._v(" "),s("li",[e._v("使用v-for指令时，必须提供key。")]),e._v(" "),s("li",[e._v("避免v-for和v-if用在一起，"),s("a",{attrs:{href:"https://cn.vuejs.org/v2/style-guide/index.html#%E9%81%BF%E5%85%8D-v-if-%E5%92%8C-v-for-%E7%94%A8%E5%9C%A8%E4%B8%80%E8%B5%B7-%E5%BF%85%E8%A6%81",target:"_blank",rel:"noopener noreferrer"}},[e._v("详见"),s("OutboundLink")],1)])]),e._v(" "),e._m(4),e._v(" "),e._m(5),e._v(" "),e._m(6),e._v(" "),e._m(7),e._v(" "),e._m(8),e._v(" "),e._m(9),e._v(" "),e._m(10),e._v(" "),e._m(11),e._v(" "),s("p",[e._v("一个理想的 Vue 应用是 prop 向下传递，事件向上传递的。遵循这一约定会让你的组件更易于理解。然而，在一些边界情况下 prop 的变更或 this.$parent 能够简化两个深度耦合的组件。")]),e._v(" "),s("p",[e._v("问题在于，这种做法在很多简单的场景下可能会更方便。但请当心，不要为了一时方便 (少写代码) 而牺牲数据流向的简洁性 (易于理解)。")]),e._v(" "),e._m(12),e._v(" "),e._m(13),e._v(" "),e._m(14),e._v(" "),s("p",[e._v("在单文件组件中，除了根级组件App和布局组件之外，其它所有组件的样式都应该有作用域scope，尽量避免因覆盖UI框架默认样式的需要而取消scope\n作用域，因为这样做可能会导致切换组件时发生样式混乱，且一旦发生难以调试。")]),e._v(" "),e._m(15),e._v(" "),s("p",[e._v("禁止在css中使用元素选择器。")]),e._v(" "),e._m(16),e._v(" "),s("p",[e._v("在插件、混入等扩展中始终为自定义的私有属性使用 $_ 前缀。并附带一个命名空间以回避和其它作者的冲突 (比如 $"),s("em",[e._v("yourPluginName")]),e._v(")。"),s("a",{attrs:{href:"https://cn.vuejs.org/v2/style-guide/index.html#%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7%E5%90%8D-%E5%BF%85%E8%A6%81",target:"_blank",rel:"noopener noreferrer"}},[e._v("详见"),s("OutboundLink")],1)]),e._v(" "),e._m(17),e._v(" "),s("p",[e._v("应用特定样式和约定的基础组件 (也就是展示类的、无逻辑的或无状态的组件) 应该全部以一个特定的前缀开头，比如 Base、App 或 V。")]),e._v(" "),e._m(18),e._m(19),e._v(" "),s("p",[e._v("单文件组件的文件名（即components目录下的文件夹及文件命名）统一采用PascalCase的命名方式，即大驼峰命名法。")]),e._v(" "),e._m(20),e._v(" "),s("p",[e._v("组件/实例的选项应该有统一的顺序。\n下面为遵守官方推荐的顺序：")]),e._v(" "),e._m(21)])}),[function(){var e=this.$createElement,t=this._self._c||e;return t("h1",{attrs:{id:"vue"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue"}},[this._v("#")]),this._v(" Vue")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"template"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#template"}},[this._v("#")]),this._v(" template")])},function(){var e=this.$createElement,t=this._self._c||e;return t("ul",[t("li",[this._v("组件名必须采用kebab-case写法；")]),this._v(" "),t("li",[t("code",[this._v("props")]),this._v("写法同HTML中attribute的写法，当props过长时，请换行并注意缩进（2个缩进）；")]),this._v(" "),t("li",[this._v("组件模板应该只包含简单的表达式，复杂的表达式则应该重构为计算属性或方法。")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"directive"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#directive"}},[this._v("#")]),this._v(" directive")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"props定义"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#props定义"}},[this._v("#")]),this._v(" props定义")])},function(){var e=this.$createElement,t=this._self._c||e;return t("ul",[t("li",[this._v("props定义必须尽可能详细，至少需指出其数据类型。如果是非必需，必须同时给出默认值，防止程序出错；")]),this._v(" "),t("li",[this._v("在声明 prop 的时候，其命名应该始终使用 camelCase，而在模板和 JSX 中应该始终使用 kebab-case。")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"关于key的使用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#关于key的使用"}},[this._v("#")]),this._v(" 关于key的使用")])},function(){var e=this.$createElement,t=this._self._c||e;return t("ul",[t("li",[t("p",[this._v("v-for指令中必须提供key值，并且不能以值为中文的属性作为key；")])]),this._v(" "),t("li",[t("p",[this._v("如果一组 v-if + v-else 的元素类型相同，必须使用 key (比如两个 "),t("code",[this._v("<div>")]),this._v(" 元素)。")]),this._v(" "),t("p",[this._v("默认情况下，Vue 会尽可能高效的更新 DOM。这意味着其在相同类型的元素之间切换时，会修补已存在的元素，而不是将旧的元素移除然后在同一位置添加一个新元素。如果本不相同的元素被识别为相同，则会出现意料之外的副作用。")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"生命周期钩子"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#生命周期钩子"}},[this._v("#")]),this._v(" 生命周期钩子")])},function(){var e=this.$createElement,t=this._self._c||e;return t("ul",[t("li",[this._v("声明周期钩子中如果有大量代码，建议封装到methods选项中的方法里面，保持生命周期钩子的简洁，清晰，同时应该写清注释。")]),this._v(" "),t("li",[t("code",[this._v("mounted")]),this._v("中如果给window对象绑定了事件，必须要在"),t("code",[this._v("beforeDestory")]),this._v("钩子中取消该事件的绑定。")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"隐性的父子通信（谨慎使用）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#隐性的父子通信（谨慎使用）"}},[this._v("#")]),this._v(" 隐性的父子通信（谨慎使用）")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[t("strong",[this._v("应该优先通过 prop 和事件进行父子组件之间的通信，而不是 this.$parent 或改变 prop。")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"关于dom操作"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#关于dom操作"}},[this._v("#")]),this._v(" 关于DOM操作")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("不提倡直接进行DOM操作，包括引入JQuery等包含大量DOM操作的库，而是改以数据驱动的思想来设计程序代码。如果在特殊情况下必须进行DOM操作，\n请使用"),t("code",[this._v("this.$refs")]),this._v("来获取DOM节点，而非"),t("code",[this._v("document.getElementById")]),this._v("的方式。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"组件样式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#组件样式"}},[this._v("#")]),this._v(" 组件样式")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"元素选择器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#元素选择器"}},[this._v("#")]),this._v(" 元素选择器")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"私有属性名"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#私有属性名"}},[this._v("#")]),this._v(" 私有属性名")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"基础组件的命名"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基础组件的命名"}},[this._v("#")]),this._v(" 基础组件的命名")])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("// error\ncomponents/\n|- MyButton.vue\n|- VueTable.vue\n|- Icon.vue\n\n// correct\ncomponents/\n|- BaseButton.vue\n|- BaseTable.vue\n|- BaseIcon.vue\n\ncomponents/\n|- AppButton.vue\n|- AppTable.vue\n|- AppIcon.vue\n\ncomponents/\n|- VButton.vue\n|- VTable.vue\n|- VIcon.vue\n")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"单文件组件的命名"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#单文件组件的命名"}},[this._v("#")]),this._v(" 单文件组件的命名")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"组件-实例的选项的顺序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#组件-实例的选项的顺序"}},[this._v("#")]),this._v(" 组件/实例的选项的顺序")])},function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ol",[s("li",[e._v("副作用 (触发组件外的影响)\n"),s("ul",[s("li",[s("code",[e._v("el")])])])]),e._v(" "),s("li",[e._v("全局感知 (要求组件以外的知识)\n"),s("ul",[s("li",[s("code",[e._v("name")])]),e._v(" "),s("li",[s("code",[e._v("parent")])])])]),e._v(" "),s("li",[e._v("组件类型 (更改组件的类型)\n"),s("ul",[s("li",[s("code",[e._v("functional")])])])]),e._v(" "),s("li",[e._v("模板修改器 (改变模板的编译方式)\n"),s("ul",[s("li",[s("code",[e._v("delimiters")])]),e._v(" "),s("li",[s("code",[e._v("comments")])])])]),e._v(" "),s("li",[e._v("模板依赖 (模板内使用的资源)\n"),s("ul",[s("li",[s("code",[e._v("components")])]),e._v(" "),s("li",[s("code",[e._v("directives")])]),e._v(" "),s("li",[s("code",[e._v("filters")])])])]),e._v(" "),s("li",[e._v("组合 (向选项里合并属性)\n"),s("ul",[s("li",[s("code",[e._v("extends")])]),e._v(" "),s("li",[s("code",[e._v("mixins")])])])]),e._v(" "),s("li",[e._v("接口 (组件的接口)\n"),s("ul",[s("li",[s("code",[e._v("inheritAttrs")])]),e._v(" "),s("li",[s("code",[e._v("model")])]),e._v(" "),s("li",[s("code",[e._v("props")]),e._v(" / "),s("code",[e._v("propsData")])])])]),e._v(" "),s("li",[e._v("本地状态 (本地的响应式属性)\n"),s("ul",[s("li",[s("code",[e._v("data")])]),e._v(" "),s("li",[s("code",[e._v("computed")])])])]),e._v(" "),s("li",[e._v("事件 (通过响应式事件触发的回调)\n"),s("ul",[s("li",[s("code",[e._v("watch")])]),e._v(" "),s("li",[e._v("生命周期钩子 (按照它们被调用的顺序)\n"),s("ul",[s("li",[s("code",[e._v("beforeCreate")])]),e._v(" "),s("li",[s("code",[e._v("created")])]),e._v(" "),s("li",[s("code",[e._v("beforeMount")])]),e._v(" "),s("li",[s("code",[e._v("mounted")])]),e._v(" "),s("li",[s("code",[e._v("beforeUpdate")])]),e._v(" "),s("li",[s("code",[e._v("updated")])]),e._v(" "),s("li",[s("code",[e._v("activated")])]),e._v(" "),s("li",[s("code",[e._v("deactivated")])]),e._v(" "),s("li",[s("code",[e._v("beforeDestroy")])]),e._v(" "),s("li",[s("code",[e._v("destroyed")])])])])])]),e._v(" "),s("li",[e._v("非响应式的属性 (不依赖响应系统的实例属性)\n"),s("ul",[s("li",[s("code",[e._v("methods")])])])]),e._v(" "),s("li",[e._v("渲染 (组件输出的声明式描述)\n"),s("ul",[s("li",[s("code",[e._v("template")]),e._v(" / "),s("code",[e._v("render")])]),e._v(" "),s("li",[s("code",[e._v("renderError")])])])])])}],!1,null,null,null);t.default=_.exports}}]);